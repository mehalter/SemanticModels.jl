<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Knowledge Extraction · SemanticModels</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SemanticModels</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SemanticModels.jl</a></li><li><a class="toctext" href="../news/">News</a></li><li><a class="toctext" href="../approach/">Approaches</a></li><li><a class="toctext" href="../slides/">Slides</a></li><li><a class="toctext" href="../FluModel/">Flu Model</a></li><li><a class="toctext" href="../dubstep/">Dubstep</a></li><li><a class="toctext" href="../graph/">Knowledge Graphs</a></li><li class="current"><a class="toctext" href>Knowledge Extraction</a><ul class="internal"><li><a class="toctext" href="#Documents-1">Documents</a></li><li><a class="toctext" href="#Code-1">Code</a></li><li><a class="toctext" href="#Reconciliation-and-Disambiguation-1">Reconciliation and Disambiguation</a></li><li><a class="toctext" href="#Reasoning-1">Reasoning</a></li><li><a class="toctext" href="#API-reference-1">API reference</a></li></ul></li><li><a class="toctext" href="../validation/">Validation</a></li><li><a class="toctext" href="../library/">Library Reference</a></li><li><a class="toctext" href="../theory/">Theory</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Knowledge Extraction</a></li></ul><a class="edit-page" href="https://github.com/mehalter/SemanticModels.jl/blob/master/doc/src/extraction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Knowledge Extraction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Knowledge-Extraction-1" href="#Knowledge-Extraction-1">Knowledge Extraction</a></h1><h2><a class="nav-anchor" id="Documents-1" href="#Documents-1">Documents</a></h2><p><code>SemanticModels.jl</code> takes the opinion that the source code and documentation is more valuable than the scientific papers themselves, even though traditional scientific incentive systems focus on only the papers.</p><p>Since natural language text is primarily being used for context, understanding, and disambiguation of code information, we use rules-based methods to extract definitions and conceptual connections. The <a href="https://ml4ai.github.io/automates/">Automates</a> framework developed at the University of Arizona is very helpful for writing rules-based information extraction software. We have made <a href="https://github.com/jpfairbanks/automates">upstream contributions</a> to the Automates repository.</p><p>The primary focus of this document is the extraction of scientific knowledge from codebases. We start by describing the natural language information extraction pipeline.</p><h3><a class="nav-anchor" id="Information-Extraction-for-Semantic-Modeling-1" href="#Information-Extraction-for-Semantic-Modeling-1">Information Extraction for Semantic Modeling</a></h3><p>To select knowledge elements that should be present in knowledge graphs, we conduct information extraction on various components of our source files, including:</p><ol><li>Scientist/programmer-contributed comments within source code files.</li><li>Code phenomena such as function names, parameters, and values.</li></ol><p>Ongoing work involves building extractors for:</p><ol><li>Research publications.</li><li>Documentation for libraries and frameworks utilized within the domains of epidemiology and information diffusion.</li></ol><h4><a class="nav-anchor" id="Information-Extraction-Pipeline-1" href="#Information-Extraction-Pipeline-1">Information Extraction Pipeline</a></h4><ol><li>Process source files including research papers, source code, and documentation files into plain text or JSON document formats.</li><li>Extract natural language text such as docstrings and comments.</li><li>Parse source code with to identify function names and parameters.</li><li>Match modeling text concepts with code variables using lexical-tokens.</li><li>Run <a href="https://github.com/ml4ai/automates">Automates</a> rule-based extraction on the text associated with each code concept.</li><li>Create knowledge elements (e.g., vertices and edges) from the tuples associated with rule matches.</li></ol><p>SemanticModels has created rules to extract phenomena such as definitions of parameters. These same parameters can then be recognized within source code, beginning with lexical matching for mapping human language definitions to specific source code instantiations.</p><p>We are currently in the process of collecting and annotating ground truth data to use in constructing machine learning models to do information extractions based on information elements of interest that we identify in use case planning for  meta-modeling related functionalities users will be able to work with.</p><h2><a class="nav-anchor" id="Code-1" href="#Code-1">Code</a></h2><p>SemanticModels currently supports extracting knowledge from the static syntactic level information that is accessible from the source code. We use the same Julia code parser as the <code>julia</code> program.</p><p>This parser takes text representations of Julia code and returns an abstract syntax tree (AST). We then walk this AST looking for Julia program expressions that create information. For example, function definitions, variable assignments and module imports. We recurse into the function definitions to find the local variable definitions (and closures) used in implementing the functions. </p><p>This form of static program analysis provides a more direct way to access user defined functions. However it cannot access the type information and run time values. For this we use <code>Cassette.jl</code>, which is a library for context-dependent execution. SemanticModels uses a custom compiler pass to access code infomation and extract information at compile time. In addition, we use the <code>overdub</code> component of Cassette to build a tracer for capturing run time values. Since Julia syntax is very regular and metaprogramming is a standard (albeit advanced) practice in the Julia community, the syntax trees and <code>CodeInfo</code> objects are designed to be manipulated programmatically, which makes writing recursive generic syntax extraction rules straightforward.</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>We can read in the file <code>examples/epicookbook/notebooks/KeelingRohani/SISModel.jl</code></p><pre><code class="language-julia">using DifferentialEquations

# # Model Specifications
# - SH num of high risk susceptible
# - IH num of high risk infected 
# - SL num of low risk susceptible
# - IL num of low risk infected
# # Parameters
# - beta represents the determines the contact and transmission rates
# - gamma the rate at which treatment is sought

function sis_ode(du,u,p,t)
        SH,IH,SL,IL = u
        betaHH,betaHL,betaLH,betaLL,gamma=p
        du[1]=-(betaHH*IH+betaHL*IL)*SH+gamma*IH
        du[2]=+(betaHH*IH+betaHL*IL)*SH-gamma*IH
        du[3]=-(betaLH*IH+betaLL*IL)*SL+gamma*IL
        du[4]=+(betaLH*IH+betaLL*IL)*SL-gamma*IL
end

parms =[10,0.1,0.1,1,1]
init=[0.19999,0.00001,0.799,0.001]
tspan=tspan = (0.0,15.0)

sis_prob = ODEProblem(sis_ode,init,tspan,parms)
sis_sol = solve(sis_prob,saveat=0.1);

using Plots
plot(sis_sol,xlabel=&quot;Time (Years)&quot;,ylabel=&quot;Proportion of Population&quot;)</code></pre><p>and run it through the code syntactic extractor, which will produce the following information:</p><pre><code class="language-julia">┌ Info: script uses modules
│   modules =
│    2-element Array{Any,1}:
│     Any[:DifferentialEquations]
└     Any[:Plots]

┌ Info: script defines functions
│   funcs =
│    1-element Array{Any,1}:
│     :(sis_ode(du, u, p, t)) =&gt; quote
│        #= none:28 =#
│        (SH, IH, SL, IL) = u
│        #= none:29 =#
│        (betaHH, betaHL, betaLH, betaLL, gamma) = p
│        #= none:30 =#
│        du[1] = -((betaHH * IH + betaHL * IL)) * SH + gamma * IH
│        #= none:31 =#
│        du[2] = +((betaHH * IH + betaHL * IL)) * SH - gamma * IH
│        #= none:32 =#
│        du[3] = -((betaLH * IH + betaLL * IL)) * SL + gamma * IL
│        #= none:33 =#
│        du[4] = +((betaLH * IH + betaLL * IL)) * SL - gamma * IL
└    end

┌ Info: script defines glvariables
│   funcs =
│    5-element Array{Any,1}:
│        :parms =&gt; :([10, 0.1, 0.1, 1, 1])
│         :init =&gt; :([0.19999, 1.0e-5, 0.799, 0.001])
│        :tspan =&gt; :(tspan = (0.0, 15.0))
│     :sis_prob =&gt; :(ODEProblem(sis_ode, init, tspan, parms))
└      :sis_sol =&gt; :(solve(sis_prob, saveat=0.1))

┌ Info: sis_ode(du, u, p, t) uses modules
└   modules = 0-element Array{Any,1}
┌ Info: sis_ode(du, u, p, t) defines functions
└   funcs = 0-element Array{Any,1}
┌ Info: sis_ode(du, u, p, t) defines glvariables
│   funcs =
│    6-element Array{Any,1}:
│                            :((SH, IH, SL, IL)) =&gt; :u
│     :((betaHH, betaHL, betaLH, betaLL, gamma)) =&gt; :p
│                                       :(du[1]) =&gt; :(-((betaHH * IH + betaHL * IL)) * SH + gamma * IH)
│                                       :(du[2]) =&gt; :(+((betaHH * IH + betaHL * IL)) * SH - gamma * IH)
│                                       :(du[3]) =&gt; :(-((betaLH * IH + betaLL * IL)) * SL + gamma * IL)
└                                       :(du[4]) =&gt; :(+((betaLH * IH + betaLL * IL)) * SL - gamma * IL)
┌ Info: Edges found
└   path = &quot;examples/epicookbook/notebooks/KeelingRohani/SISModel.jl&quot;
(:Modeling, :takes, :parms, :([10, 0.1, 0.1, 1, 1]))
(:Modeling, :has, :parms, :prop_collection)
(:Modeling, :takes, :init, :([0.19999, 1.0e-5, 0.799, 0.001]))
(:Modeling, :has, :init, :prop_collection)
(:Modeling, :structure, :tspan, :((0.0, 15.0)))
(:Modeling, :comp, :tspan, 0.0)
(:Modeling, :comp, :tspan, 15.0)
(:Modeling, :output, :sis_prob, :(ODEProblem(sis_ode, init, tspan, parms)))
(:Modeling, :input, :sis_ode, Symbol[:init, :tspan, :parms])
(:Modeling, :output, :sis_sol, :(solve(sis_prob, saveat=0.1)))
(:Modeling, :input, :sis_prob, Symbol[Symbol(&quot;saveat=0.1&quot;)])
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :destructure, :((SH, IH, SL, IL)), :u)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :u, :SH)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :u, :IH)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :u, :SL)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :u, :IL)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :destructure, :((betaHH, betaHL, betaLH, betaLL, gamma)), :p)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :p, :betaHH)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :p, :betaHL)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :p, :betaLH)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :p, :betaLL)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :comp, :p, :gamma)
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :output, :(du[1]), :(-((betaHH * IH + betaHL * IL)) * SH + gamma * IH))
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :input, :(-((betaHH * IH + betaHL * IL)) * SH), Symbol[Symbol(&quot;gamma * IH&quot;)])
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :output, :(du[2]), :(+((betaHH * IH + betaHL * IL)) * SH - gamma * IH))
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :input, :(+((betaHH * IH + betaHL * IL)) * SH), Symbol[Symbol(&quot;gamma * IH&quot;)])
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :output, :(du[3]), :(-((betaLH * IH + betaLL * IL)) * SL + gamma * IL))
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :input, :(-((betaLH * IH + betaLL * IL)) * SL), Symbol[Symbol(&quot;gamma * IL&quot;)])
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :output, :(du[4]), :(+((betaLH * IH + betaLL * IL)) * SL - gamma * IL))
(&quot;Modeling.sis_ode(du, u, p, t)&quot;, :input, :(+((betaLH * IH + betaLL * IL)) * SL), Symbol[Symbol(&quot;gamma * IL&quot;)])</code></pre><p>This extractor provides edges to the <a href="../graph/#Knowledge-Graphs-1">Knowledge Graphs</a>. Once the extraction is complete, the knowledge graph can be stored and transmitted to scientists across many disciplines. These knowledge graphs are a compact representation of the code and text. As new papers and codes are written, they can be ingested into an online graph database providing access to many scholars.</p><h2><a class="nav-anchor" id="Reconciliation-and-Disambiguation-1" href="#Reconciliation-and-Disambiguation-1">Reconciliation and Disambiguation</a></h2><p>As our information extraction pipeline outlined above illustrates, the task of knowledge graph construction implicitly requires us to either assert or infer a crosswalk between (1) vertices extracted from text and vertices extracted from code with a common higher-level source (e.g., a published paper that is associated with source code that also includes comments); and (2) vertices (and by extension, edges) that are already present in the graph, when the combined information conveyed by the user-provided vertex name, and provided/inferred vertex type is not a sufficient guarantee of uniqueness, and/or a reliable signal of user intent (e.g., the user may seek to (1) enforce uniqueness by differentiating a new vertex, <span>$v_i$</span>, from lexically identical but semantically different vertices <span>$\in V$</span>, or (2) insert <span>$v_i$</span> iff <span>$V \cap_{semantic} v_i = \emptyset$</span>, regardless of their lexical (dis)similarity).</p><p>When two or more knowledge artifacts share provenance (e.g., the narrative text, programmer-provided comments, and source code that, when taken in tandem, represent a single <a href="http://epirecip.es/epicookbook/chapters/1host1vector/julia">recipe</a> in the <a href="http://epirecip.es/epicookbook/chapters/simple">Epicookbook</a>), we currently consider code text and markdown/comments text as strings, and use rule based learning to associate text with code objects; these lexical matches are then parsed in an effort to extract edges of the type representation (abbreviated <code>repr</code>), which connect a (code) <code>type</code> source vertex to a (scientific) <code>concept</code> destination vertex.</p><p>We intend to extend this approach in the future by: (1) creating new syntactical parsing rules to capture additional relationships; (2) considering the ways in which information related to scope, and/or position within the program-level call graph can be informative for the purpose of co-reference resolution; and/or (3) representing both sources of text sequences as real-valued vectors, to determine whether cosine similarity and/or RNN-based approaches can help to detect co-referential lexical elements <a href="#footnote-1">[1]</a>.</p><p>With respect to the question of how to best assess/resolve ambiguity surrounding the uniqueness of a vertex upon ingestion, we currently guarantee uniqueness by appending a randomly generated string to the concatenation of the (raw-text) vertex name and the (schema-consistent) vertex type. This approach biases the graph toward smaller, disconnected subgraphs, and makes it harder for us to benefit from the semantic equivalence that often exists when different text and/or code artifacts from the same domain are parsed for the purpose of ingestion.</p><p>We intend to develop a more nuanced approach to vertex ingestion that incorporates exogenous, domain-specific information (for example, a lookup table of parameters that are commonly used within the epidemiological literature; known model imports, etc.). We can begin by manually constructing a dataset with examples of how these known elements are represented in code, and can then train an NER model to detect such references when they occur, so that we can avoid insertion of lexically distinct but (fuzzily) semantically equivalent vertices and encourage semantically meaningful consolidation, resulting in a more connected, parsimonious graph.</p><p>We may also find it helpful to leverage user-provided metadata (such as source/provenance information), and/or unsupervised learning techniques, including clustering methods, for this task as the complexity of the graph grows, and/or knowledge artifacts from additional domains with potentially conflicting named entities are introduced. We may also find it helpful to compare the semantic saliency of the (graph-theoretic) neighborhood(s) that might result from either the source or destination vertex of a new edge being mapped to each of a set of feasible existing vertices; this approach could also benefit from provenance-related metadata.</p><h2><a class="nav-anchor" id="Reasoning-1" href="#Reasoning-1">Reasoning</a></h2><p>Once the information is extracted from the documentation and code, we can visualize the knowledge as a graph.</p><p><img src="../img/reasoning_sir.dot.svg" alt="Knowledge Graph from epicookbook"/></p><p>This knowledge graph contains all the connections we need to combine components across models. Once can view this combination as either a modification of one model by substituting components of another model, or as the automatic generation of a metamodel by synthesizing components from the knowledge graph into a single coherent model. Further theoretical analysis of metamodeling and model modification as mathematical problems is warranted to make these categories unambiguous and precisely defined.</p><p>Once we identify a subgraph of related components we can identify the graft point between the two models. We look for a common variable that is used in two models, specifically in a derivative calculation. We find the variable <code>S</code> which appears in <code>dS</code> and <code>dY</code> (as <code>S=Y[1]</code> and <code>dY = derivative(Y)</code>). The knowledge that <code>dS, dY</code> are derivatives comes from the background knowledge of modeling that comes from reading textbooks and general scientific knowledge, while the fact that <code>S</code> and <code>Y[1]</code> both appear in an expression <code>mu-beta*S*I - mu*S</code> comes from the specific documents and codebases under consideration by the metamodeler.</p><p><img src="../img/reasoning_sir_subgraph.dot.svg" alt="Knowledge Subgraph showing model modification"/></p><p>This subgraph must then extend out to capture all of the relevant information such as the parameter sets encountered, the function calls that contain these variables and expressions. We have found the <em>largest relevant subgraph</em> for some unspecified definition of <em>relevance</em>. From this subgraph, a human modeler can easily instruct the SemanticModels system on how to combine the <code>SEIRmodel</code> and <code>ScalingModel</code> programs into a single model and generate a program to execute it.</p><p>In order to move beyond this relatively manual approach to model modification and metamodeling, it is helpful to frame each of our intended <a href="../usecases/">use cases</a> as an optimization problem, in which the scientist&#39;s required unitful input(s) and/or unitful output(s) (including expected deviation from observed/expected patterns, in the case of model validation) can be formally expressed as constraints, and relevance can be objectively and quantifiably represented, so that competing feasible flows can be assessed, ranked, and returned to the scientist to augment their understanding. The specification of the objective function, choice of traversal algorithm(s), and the use of edge weights to convey algorithmically meaningful information, will vary by use case.</p><p>For example, the metamodeling use case, in which the scientist begins with a vector of known unitful input and a vector of unitful output whose value is unknown, can be formulated as an <span>$s-t$</span> max flow problem, with our input vertex as <span>$s$</span>, our output vertex as <span>$t$</span>, and edge weights corresponding to the frequency with which a given edge is empirically observed within a domain-specific text and code corpus. To ensure tractability at scale, we may want to consider a weighting scheme to avoid integer constraints. This approach may also help us to identify disconnected subgraphs, which, if linked by cut-crossing edges, would represent a feasible flow; the scientific insight here is that such a set of edges might represent &quot;missing&quot; functions capable of transforming the &quot;input&quot; src vertex of a cut-crossing edge with its output dst vertex. These function(s) could then be ingested or written by scientists.</p><p>While we intend to proceed with algorithmic development of this nature in the near term, it&#39;s worth noting that the goal of this project is to augment scientists and their workflows. As such, we envision a human-in-the-loop, semi-automated approach, in which the scientist is in control and has the ability to instruct the machine by providing information about what the scientist already knows, and what they wish to do with that knowledge (e.g., modify, combine, validate) existing models and scripts. </p><p>Any API that supports augmenting scientists will require some human intervention in the reasoning and generation stages as the system must get input from the user as to the questions being asked of it. We view this to analogous to a data analyst working with a database system: a query planning system is able to optimize queries based on knowledge about the schema and data statistics, but it must still wait for a human to provide a query. In this way, even as our development efforts proceed, <code>SemanticModels</code> will rely upon user guidance for reasoning and generation tasks.</p><h2><a class="nav-anchor" id="API-reference-1" href="#API-reference-1">API reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.AbstractCollector" href="#SemanticModels.Parsers.AbstractCollector"><code>SemanticModels.Parsers.AbstractCollector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractCollector</code></pre><p>subtypes of AbstractCollector support extracting and collecting information from input sources.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.FuncCollector" href="#SemanticModels.Parsers.FuncCollector"><code>SemanticModels.Parsers.FuncCollector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FuncCollector{T} &lt;: AbstractCollector</code></pre><p>collects function definitions and names</p></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.MetaCollector" href="#SemanticModels.Parsers.MetaCollector"><code>SemanticModels.Parsers.MetaCollector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MetaCollector{T,U,V,W} &lt;: AbstractCollector</p><p>collects multiple pieces of information such as</p><ul><li>exprs: expressions</li><li>fc: functions</li><li>vc: variable assignments</li><li>modc: module imports</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L56-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.defs-Tuple{Any}" href="#SemanticModels.Parsers.defs-Tuple{Any}"><code>SemanticModels.Parsers.defs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">defs(body)</code></pre><p>collect the function definitions and variable assignments from a module expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L99-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.funcs-Tuple{Any}" href="#SemanticModels.Parsers.funcs-Tuple{Any}"><code>SemanticModels.Parsers.funcs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">funcs(body)</code></pre><p>collect the function definitions from a module expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SemanticModels.Parsers.parsefile" href="#SemanticModels.Parsers.parsefile"><code>SemanticModels.Parsers.parsefile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parsefile(path)</code></pre><p>read in a julia source file and parse it.</p><p>Note: If the top level is not a simple expression or module definition the file is wrapped in a Module named modprefix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mehalter/SemanticModels.jl/blob/5de877840414259ae58fe7c5e9b7bfe8d026d68b/src/parse.jl#L8-L14">source</a></section><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p><a href="https://arxiv.org/abs/1803.09473">https://arxiv.org/abs/1803.09473</a></p></div><footer><hr/><a class="previous" href="../graph/"><span class="direction">Previous</span><span class="title">Knowledge Graphs</span></a><a class="next" href="../validation/"><span class="direction">Next</span><span class="title">Validation</span></a></footer></article></body></html>
